---
layout:     post                    # 使用的布局（不需要改）
title:      Java 程序员都该懂的 JVM 内存区域              # 标题 
subtitle:   #副标题
date:       2019-02-15              # 时间
author:     Howie                      # 作者
header-img: img/JVM-MemoryArea.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - JVM
    - 内存

---
>对于 Java 程序员来说，在 JVM 自动内存管理机制的帮助下，不再需要为每一个 new 操作去写对应的 delete/free 代码，不容易出现内存泄露和内存溢出的问题。不过正因如此，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄露和内存溢出的问题，那么排查错误将会非常艰难。

# 一. 内存区域
---
虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域，这些区域各司其职

## 1. 线程私有
下面这 3 个区域都是线程私有的区域，每个线程独占一份
### （1）程序计数器
- 当前线程所执行的字节码的行号指示器
- 通过改变计数器的值来选取下一条执行的字节码指令
- 帮助完成分支，循环，跳转，异常处理，线程恢复等基础功能
- 多线程环境中，为了正常完成线程的切换，使得各个线程能恢复到正确的执行位置，因此每条线程都需要一个程序计数器
- 唯一一个不会出现 OutOfMemoryError 情况的区域


### （2）虚拟机栈
- 每个方法执行时都会创建一个栈帧，当方法被调用，栈帧入栈，方法执行完成，出栈
- 每个栈帧存储局部变量表，操作栈，动态链接，方法出口等
- 局部变量表存储了当前方法的局部变量，包括基本数据类型，对象引用（指针）以及 returnAddress 类型（指向一条字节码指令的地址）
- 可能出现的两种异常：
 StackOverflowError：栈溢出，线程请求的栈深度大于虚拟机允许的深度  
 OutOfMemoryError：内存溢出，如果虚拟机栈可以动态扩展，那么如果扩展时无法申请到足够的内存，则抛出异常

### （3）本地方法栈
- 作用，运行机制，异常类型等与虚拟机栈相同
- 为 native 方法服务
- 很多虚拟机中，本地方法栈和虚拟机栈合二为一

## 2. 线程共享
下面两个为线程共享的区域
### （4）堆
- 虚拟机管理的内存中最大的一块
- 存放对象实例
- 垃圾回收器管理的主要区域，也被称为 GC 堆，并因此可以细分为新生代和老年代
- 可以处于不连续的空间中
- 当没有内存完成实例分配，堆也无法扩展时，抛出 OutOfMemoryError

### （5）方法区
- 存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等
- 垃圾回收行为在这个区域很少出现，因此也被称作为“永久代”

值得注意的是，从 Java 8 开始，方法区被移除，取而代之的是一个叫元空间（Metaspace）的区域

#### （6）运行时常量池
- Java 6 及之前属于方法区的一部分；Java 7 后被移入堆区域
- 存放编译器生产的各种字面量和符号引用，在类加载时期存入运行时常量池


# 二. 了解 Java 对象
---
## 1. 对象的创建
对象的创建过程中有以下几大步骤：
### （1）类加载检查
当虚拟机遇到一个 new 指令，说明要创建对象了；但在创建对象之前，会先去检查这个类是否已经加载过，解析和初始化过，如果没有，则先执行类加载过程

### （2）分配内存
在堆中划分出一块确定大小的内存，分配方式有两种

#### 分配方法
- 指针碰撞：使用这种方法，堆内存必须是规整的（用过的放一边，空闲的放一边），然后中间放一个指针作为分界点。分配内存时只需要将指针挪一段与对象大小相等的距离即可
- 空闲列表：如果堆内存不规整，就只能使用空闲列表法了。JVM 维护一个列表来记录内存块的使用情况；分配时找到一块足够大的空间划分给对象然后更新表记录即可

#### 保证线程安全
为了保证线程安全，避免同一块区域同时分配给多个对象，通常使用两种方法
- CAS：每当要写入数据时，先比较当前值（工作内存）与主内存中的值是否一致，是则进行写入，否则重新获取值
- TLAB：每个线程预先分配一小块内存，称为本地线程分配缓冲（TLAB）；如果某个线程的 TLAB 用完，需要分配新的 TLAB，这些则需要进行同步锁定

### （3）初始化零值
将分配到的内存空间都初始化为零值；这样可以使得对象在代码中不赋初始值就直接使用

```
public class Person {
    int age;

    public static void main(String[] args) {
        Person person = new Person();
        System.out.println(person.age);
    }
}
```

类似这样的情况，age 被默认赋值为 0

### （4）设置对象头
将类的自身运行时数据（HashCode，GC 分代年龄，锁状态标志等）；类型指针（指向类元数据，确定是哪个类的实例）存放在对象头中

### （5）执行 init 方法
前面几步完成后，对于虚拟机，一个新对象已经产生了，但对于 java 程序，需要执行 init 方法后，一个真正的对象才完全产生出来

## 二. 对象的内存布局
堆里面存放的是对象实例，对象实例由三个部分组成

![](https://upload-images.jianshu.io/upload_images/8807674-a9e0080417bef3a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


- 对象头：存储自身运行时数据（HashCode，GC 分代年龄，锁状态标志等）；类型指针，指向类元数据（确定是哪个类的实例）
- 实例变量：记录对象的各种属性数据信息
- 填充数据：用于对齐字节（JVM 对对象起始地址的字节数有要求，是8字节的整数倍

