---
layout:     post                    # 使用的布局（不需要改）
title:      Java 程序员都该懂的 JVM 垃圾回收机制              # 标题 
subtitle:   #副标题
date:       2019-02-16              # 时间
author:     Howie                      # 作者
header-img: img/JVM-GC.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - JVM

---
>垃圾收集是一项自动化的技术。可是当我们排查各种内存问题，或者当垃圾收集成为系统达到更高并发量的瓶颈时，我们需要对这些原本自动化的技术进行必要的监控和调节，所有我们很有必要学习 JVM 的垃圾收集机制。

## 一. 什么区域需要回收？为什么需要回收？
垃圾回收也称为 GC （Garbage Collection），或者可以称为垃圾收集。

对于线程私有的三个部分（程序计数器，虚拟机栈和本地方法栈），不怎么需要考虑回收问题，原因：
- 在方法结束或线程结束时，内存便跟着回收走了，他们随线程而生，线程而灭
- 而且对于栈来说，每个栈帧中分配多少内存基本在类结构确定下来的时候就已经确定了。

对于线程共享的两个部分（堆和方法区，主要是堆），需要考虑回收，原因：
- 程序只有处于运行的时候才能知道会创建哪些对象
- 内存的分配和回收都是动态的

对于堆来说，如果不进行垃圾回收，内存迟早都会被消耗空，因为我们在不断的分配内存空间而不进行回收。除非内存无限大，我们可以任性的分配而不回收，但是事实并非如此。所以，垃圾回收是必须的。

## 二. 如何判断对象是否存活？
在对堆进行垃圾回收前，必须确定每个对象是否还存活着；而这个判断过程主要是以下两种算法

### 1. 引用计数算法
给对象添加一个引用计数器，每当有一个地方引用它，计数器值加 1；每当引用失效，计数器减 1；当某个对象任何时候计数器值都是 0 时，这个对象就“死”了

缺点：很难解决对象之间循环引用的问题，也因此主流的 JVM 都没有使用该算法来管理内存

```
public class GCTest {
    Object object;

    private static void test() {
        GCTest test1 = new GCTest();
        GCTest test2 = new GCTest();
        
        test1.object = test2;
        test2.object = test1;  
        
        test1 = null;
        test2 = null;
    }
}
```
类似这样的例子，由于 test1 和 test2 相互引用对方，即使这两个对象已经不可能再被访问到（两个变量都已经指向 null），引用计数算法也无法让垃圾收集器对它们进行回收

### 2. 可达性分析算法
这是主流 JVM 使用的回收算法

通过一系列称为 GC Roots 的对象作为起始点，从这些节点向下搜索，如果一个对象与 GC Roots 对象有引用链相连，说明对象可用；反之，对象不可用

![](https://upload-images.jianshu.io/upload_images/8807674-b6f58487cce36164.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


如上图的对象 4,5,6 则需要被回收

而可作为 GC Roots 的对象包括下面几种：
- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象以及常量引用的对象
- 本地方法栈中 native 方法引用的对象

## 三. 方法区的回收
方法区很少进行垃圾回收，甚至可以不要求虚拟机对方法区进行回收，因为能回收的东西很少，因此也叫做永久代

在永久代，主要回收两个内容：废弃常量，无用的类。如果在永久代发生垃圾回收，那么这两个内容就会被清理出去（当然大多数情况下不会去对永久代进行垃圾回收操作）

## 四. 引用的类型
不论使用什么算法判断对象的存活情况，这都和“引用”息息相关

### 1. 强引用
- 简单来说就是类似 ```Object o = new Objrct``` 这样的引用
- 只要这样的关系还存在，就永不会被回收

### 2. 软引用
- 还有用但非必需的对象
- 如果将要发生内存溢出，则进行第二次回收，将这些软引用对象回收；之后如果还是没有足够的内存，再抛出内存溢出异常

可以通过 SoftReference 实现，这是 sf 对 obj 有软应用
```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
sf.get(); //如果 obj 被标记为需要被回收，则会返回null
```
SoftReference 可以用来实现类似缓存的功能

### 3. 弱引用
- 非必需对象，比软引用强度更弱
- 当垃圾收集器工作，它们就会被回收

可以通过 WeakReference 实现，通常用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾
```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
wf.get();
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
```

### 4. 虚引用
- 最弱的引用关系
- 无法通过虚引用取得一个对象的实例

可以通过 PhantomReference 实现，主要用于检测对象是否已经从内存中删除
```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
```


## 五. 垃圾回收算法
### 1. 标记——清除算法
先标记出要回收的对象，标记完成后统一清除这些对象。

缺点：
- 效率太低，标记和清除两个操作的效率都不高
- 清除后会产生大量不连续的内存空间，或者称为内存碎片。而如果我们需要分配一些较大的对象的时候，无法找到足够的连续空间是一件很麻烦的事情。

### 2. 复制算法
将内存划分为等大的两块，一次只使用一块。当其中一块用完了，就把里面的存活的对象全部复制到另一块去，然后将已经使用的那一大块一次性全部清理掉

- 优点：实现简单，运行高效，也不用担心碎片问题
- 缺点：将内存缩小了一半，代价有点高

### 3. 标记——整理算法
标记——清除算法的改进，在完成标记之后，让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存，故名叫“整理”。

### 4. 分代收集算法
当前商业虚拟机的垃圾收集都采用「分代收集」算法

分代收集算法将内存划分为新生代和老年代：

- 在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集

- 在老年代中因为对象存活率高、没有额外空间对它进行担保，就必须采用「标记 — 清理」或者「标记 — 整理」算法来回收。
